# 深度学习核心知识点总结：房价预测实战与模型构造

本文档提炼自李沐《动手学深度学习》中“Kaggle房价预测实战”与“模型构造（`nn.Module`）”两大核心板块的底层逻辑与最佳实践。

## 一、 房价预测实战（数据流转与机制）

### 1. 数据预处理与防泄漏

* **特征标准化 (StandardScaler)**：将输入特征缩放至均值为0、方差为1，消除量纲差异，加速模型收敛。
* **核心防泄漏原则**：
  * **训练集**：必须使用 `fit_transform()`（计算均值/方差并执行缩放）。
  * **测试集**：严禁重新计算，只能使用 `transform()`（直接套用训练集的均值/方差进行缩放），以符合“用历史经验评估未来未知数据”的客观规律。

### 2. PyTorch 数据喂养机制

* **`TensorDataset`**：将特征张量 X 和标签张量 y 按行进行“硬绑定”，确保每一行的特征严格对应真实的房价标签，防止张冠李戴。
* **`DataLoader`**：充当数据加载的可迭代对象（Iterable）。
  * **`batch_size`**：控制每次输入模型的样本包大小，防止显存溢出（OOM），同时提供带有一定随机噪声的梯度以提升训练效果。
  * **`shuffle=True`**：在每个 Epoch 开始前彻底打乱数据顺序，这是防止模型“死记硬背”输入顺序的核心防作弊机制。

### 3. 损失函数与评估指标脱节的陷阱

* **MSE (均方误差)**：作为训练时的“教练”，提供平滑且稳定的梯度，引导优化器更新参数。
* **Log RMSE (对数均方根误差)**：作为评估时的“裁判”。
  * **业务意义**：对于房价等长尾分布（右偏分布）的数据，取对数后计算误差本质上是在衡量**相对百分比误差**。无论10万还是1000万的房子，预测偏离10%扣除的分数是一样的。
  * **安全护栏 (`torch.clamp`)**：由于对数函数的数学特性，必须在取对数前使用 `torch.clamp(preds, min_value, max_value)` 将模型偶尔瞎猜出的负数或极小值强行截断至一个安全的正数底线（如加州房价的 0.1）。如果底线设置过低（如 1e-5），会导致裁判打出核爆级的天价惩罚分数，进而造成评估指标剧烈震荡。

---

## 二、 模型构造块 (`nn.Module`)

### 1. 万物皆 Module

在 PyTorch 中，无论是单一的层（如 `nn.Linear`）还是宏大的自定义网络，都必须继承自 `nn.Module` 基类。这是 PyTorch 搭建计算图的基石。

### 2. 核心双函数构建法

采用面向对象（OOP）方式自定义模型时，必须重写以下两个核心方法：

* **`__init__(self)`（准备零件）**：

  * 必须首行调用 `super().__init__()` 初始化父类状态。
  * 在此实例化所有包含可学习权重参数的层，并将其作为 `self` 的属性保存。PyTorch 会自动追踪这些属性，将其注册到模型的参数列表（`parameters`）中。
* **`forward(self, x)`（组装流水线）**：
  * 接收输入张量 `x`。
  * 严格定义数据流经各个层的计算顺序和逻辑。
  * **极简优势**：只需定义前向传播路径，PyTorch 的 Autograd（自动求导）引擎会在后台动态构建计算图，自动为你搞定复杂的反向传播求导过程。

### 3. `nn.Sequential` 容器

对于纯串行的线性流水线结构，可以直接使用 `nn.Sequential` 容器将各个模块（层）按顺序打包。它在内部已自动实现了依次调用各个子层 `forward` 方法的逻辑，代码极其精简。

---

## 三、 训练核心五步曲（肌肉记忆版）

任何 PyTorch 模型的标准训练循环，都必须严格遵守以下五步：

```python
# 假设已经进入了 for batch_X, batch_y in train_loader: 的批次循环
optimizer.zero_grad()                  # 1. 清空：清除上一步残余的梯度，防止梯度累加干扰
predictions = model(batch_X)           # 2. 前向传播：模型执行做题过程，给出预测值
loss = criterion(predictions, batch_y) # 3. 计算误差：对比预测值与真实标签，计算 Loss
loss.backward()                        # 4. 反向传播：引擎自动计算网络中每个参数的梯度
optimizer.step()                       # 5. 更新参数：优化器根据算出的梯度，真正修改模型权重